import { DriftClient, DriftEnv, OptionalOrderParams, SignedMsgOrderParamsDelegateMessage, SignedMsgOrderParamsMessage, UserAccount } from '..';
import { Keypair, TransactionInstruction } from '@solana/web3.js';
export interface AccountGetter {
    mustGetUserAccount(publicKey: string): Promise<UserAccount>;
}
export type SwiftOrderSubscriberConfig = {
    driftClient: DriftClient;
    userAccountGetter?: AccountGetter;
    driftEnv: DriftEnv;
    endpoint?: string;
    marketIndexes: number[];
    /**
        In the future, this will be used for verifying $DRIFT stake as we add
        authentication for delegate signers
        For now, pass a new keypair or a keypair to an empty wallet
    */
    keypair: Keypair;
};
export declare class SwiftOrderSubscriber {
    private config;
    private heartbeatTimeout;
    private readonly heartbeatIntervalMs;
    private ws;
    private driftClient;
    userAccountGetter?: AccountGetter;
    onOrder: (orderMessageRaw: any, signedMessage: SignedMsgOrderParamsMessage | SignedMsgOrderParamsDelegateMessage, isDelegateSigner?: boolean) => Promise<void>;
    subscribed: boolean;
    constructor(config: SwiftOrderSubscriberConfig);
    unsubscribe(): void;
    getSymbolForMarketIndex(marketIndex: number): string;
    generateChallengeResponse(nonce: string): string;
    handleAuthMessage(message: any): void;
    subscribe(onOrder: (orderMessageRaw: any, signedMessage: SignedMsgOrderParamsMessage | SignedMsgOrderParamsDelegateMessage, isDelegateSigner?: boolean) => Promise<void>, acceptSanitized?: boolean): Promise<void>;
    getPlaceAndMakeSignedMsgOrderIxs(orderMessageRaw: any, signedMsgOrderParamsMessage: SignedMsgOrderParamsMessage | SignedMsgOrderParamsDelegateMessage, makerOrderParams: OptionalOrderParams): Promise<TransactionInstruction[]>;
    private startHeartbeatTimer;
    private reconnect;
}
